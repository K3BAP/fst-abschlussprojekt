out: output collection[string][int] of string;
p:Project = input;

count_fields_methods := function(class: Declaration): array of int {
    counts: array of int = {0, 0};

    counts[0] = len(class.fields);

    visit (class, visitor {
        before method: Method -> {
            counts[1] = counts[1] + 1;
        }
    });

    return counts;
};

cyclomatic_complexity := function(method: Method): int {
    cc: int = 1;
    visit (method, visitor {
        before statement: Statement -> {
            if (statement.kind == StatementKind.IF 
                || statement.kind == StatementKind.FOR
                || statement.kind == StatementKind.WHILE
                || statement.kind == StatementKind.DO
            ) 
            {
                cc = cc + 1;
            }

            if (statement.kind == StatementKind.SWITCH) {
                cases: int = 0;
                visit (statement, visitor {
                    before statement: Statement -> {
                        if (statement.kind == StatementKind.CASE) {
                            cases = cases + 1;
                        }
                    }
                });

                cc = cc + cases - 1;
            }
        }
    });
    return cc;
};

count_statements := function(method: Method): int {
    count: int = 0;
    visit (method, visitor {
        before statement: Statement -> {
            count = count + 1;
        }
    });

    return count;
};

count_parameters := function(method: Method): int {
    return len(method.arguments);
};

is_large_class := function(class: Declaration): bool {
    counts: array of int = count_fields_methods(class);
    # Number of class fields
    if (counts[0] > 10) {
        return true;
    }
    # Number of methods
    if (counts[1] > 15) {
        return true;
    }
    # No match
    return false;
};

is_long_method := function(method: Method): bool {
    stmt_count: int = count_statements(method);
    cyc_comp: int = cyclomatic_complexity(method);
    if (stmt_count > 15) {
        return true;
    }
    if (cyc_comp > 10) {
        return true;
    }
    return false;
};

is_long_parameter_list := function(method: Method): bool {
    par_count: int = count_parameters(method);
    if (par_count > 4) return true;
    return false;
};

calculate_smells := function(node: CodeRepository) {
    smell_count: int = 0;
    statement_count: int = 0;
    visit(node, visitor {
        before node: Declaration -> {
            if (node.kind == TypeKind.CLASS && is_large_class(node)) {
                smell_count = smell_count + 1;
            }
        }

        before node: Method -> {
            if (is_long_method(node)) {
                smell_count = smell_count + 1;    
            }
            if (is_long_parameter_list(node)) {
                smell_count = smell_count + 1;
            }
        }

        before node: Statement -> {
            statement_count = statement_count + 1;
        }
    });
    if (statement_count > 0)
        out[p.name][0] << format("%d; %d", smell_count, statement_count);
};


visit(p, visitor{
    before node: CodeRepository -> {
        calculate_smells(node);
    }
});